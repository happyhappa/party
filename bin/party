#!/usr/bin/env bash
#
# party - Creates 3-tier tmux layout for LLM orchestration
#
# Layout:
# ┌────────────┬────────────────────┐
# │            │        CC (50%)    │
# │     OC     ├────────────────────┤
# │            │        CX (50%)    │
# └────────────┴────────────────────┘
#
# Usage: party [session-name]
#
# Configuration (optional ~/.config/relay/party.conf):
#   RELAY_OC_DIR, RELAY_CC_DIR, RELAY_CX_DIR - working directories
#   RELAY_OC_CMD, RELAY_CC_CMD, RELAY_CX_CMD - launch commands
#
# Defaults:
#   OC: auto-detects -c flag (continues if prior session exists)
#   CC: fresh session in $PWD
#   CX: fresh codex in $PWD
#

set -euo pipefail

PROJECT_DIR="${2:-$PWD}"
PROJECT_NAME=$(basename "$PROJECT_DIR")
SESSION="${1:-party-${PROJECT_NAME}}"
CONFIG_FILE="$HOME/.config/relay/party.conf"

# Per-project relay state (outside git, not tracked)
RELAY_SHARE_DIR="$PROJECT_DIR/.relay"
export RELAY_MAIN_DIR="$PROJECT_DIR/main"
export RELAY_SHARE_DIR
export RELAY_STATE_DIR="$RELAY_SHARE_DIR/state"
export RELAY_LOG_DIR="$RELAY_SHARE_DIR/log"
export RELAY_INBOX_DIR="$RELAY_SHARE_DIR/outbox"
export BEADS_DIR="$RELAY_MAIN_DIR/.beads"
export RELAY_TMUX_SESSION="$SESSION"

RELAY_LOG="$RELAY_LOG_DIR/events.jsonl"

# Source optional config
[[ -f "$CONFIG_FILE" ]] && source "$CONFIG_FILE"

# Per-pane working directories
OC_DIR="${RELAY_OC_DIR:-$PROJECT_DIR/main}"
CC_DIR="${RELAY_CC_DIR:-$PROJECT_DIR/cc-wt}"
CX_DIR="${RELAY_CX_DIR:-$PROJECT_DIR/cx-wt}"

# Auto-trust mise config in worktrees (same git content, different paths need separate trust)
for dir in "$CC_DIR" "$CX_DIR"; do
    [[ -f "$dir/.mise.toml" ]] && mise trust "$dir/.mise.toml" 2>/dev/null || true
done

# Slug helper (used for session detection and project-dirs.json)
dir_to_slug() { echo "-${1#/}" | tr '/_' '--'; }

# Detect if OC has prior session history (for -c flag)
OC_SLUG=$(dir_to_slug "$OC_DIR")
if ls "$HOME/.claude/projects/${OC_SLUG}"/*.jsonl &>/dev/null; then
    OC_CONTINUE_FLAG="-c"
else
    OC_CONTINUE_FLAG=""
fi

# Per-agent launch commands
OC_CMD="${RELAY_OC_CMD:-claude ${OC_CONTINUE_FLAG} --model claude-opus-4-6 --dangerously-skip-permissions}"
CC_CMD="${RELAY_CC_CMD:-claude --model claude-opus-4-6 --dangerously-skip-permissions}"
CX_CMD="${RELAY_CX_CMD:-codex -a never -s workspace-write --add-dir /tmp --add-dir $RELAY_SHARE_DIR --add-dir ~/.cache --add-dir $RELAY_INBOX_DIR/cx}"

# Resolve admin-loop.sh path (follows symlinks to find the real script dir)
ADMIN_LOOP="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")/../daemon/scripts/admin/admin-loop.sh"
if [[ ! -x "$ADMIN_LOOP" ]]; then
    # Fallback: check ~/.local/bin symlink target
    ADMIN_LOOP="$HOME/.local/bin/admin-loop.sh"
fi

# Colors for status
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

log() {
    echo -e "${GREEN}[party]${NC} $1"
}

err() {
    echo -e "${RED}[party]${NC} $1" >&2
}

# Handle 'party stop' subcommand
if [[ "${1:-}" == "stop" ]]; then
    shift
    SESSION="${1:-}"
    if [[ -z "$SESSION" ]]; then
        err "Usage: party stop <session-name>"
        err "Running party sessions:"
        tmux list-sessions -F '#{session_name}' 2>/dev/null | grep '^party-' || err '  (none)'
        exit 1
    fi
    # Read RELAY_STATE_DIR from the tmux session's environment
    STATE_DIR=$(tmux show-environment -t "$SESSION" RELAY_STATE_DIR 2>/dev/null | cut -d= -f2-)
    if [[ -z "$STATE_DIR" ]]; then
        err "Cannot find RELAY_STATE_DIR for session $SESSION"
        exit 1
    fi
    log "Stopping party session '$SESSION'..."
    # Kill admin-loop
    [[ -f "$STATE_DIR/admin-loop.pid" ]] && kill $(cat "$STATE_DIR/admin-loop.pid") 2>/dev/null || true
    # Kill relay daemon
    [[ -f "$STATE_DIR/relay-daemon.pid" ]] && kill $(cat "$STATE_DIR/relay-daemon.pid") 2>/dev/null || true
    # Kill tmux session
    tmux kill-session -t "$SESSION" 2>/dev/null || true
    log "Session '$SESSION' stopped."
    exit 0
fi

# Check if session already exists
if tmux has-session -t "$SESSION" 2>/dev/null; then
    log "Session '$SESSION' already exists. Attaching..."
    exec tmux attach -t "$SESSION"
fi

# Ensure relay directories and log file exist
mkdir -p "$RELAY_STATE_DIR" "$RELAY_LOG_DIR" "$RELAY_INBOX_DIR"/{oc,cc,cx}
touch "$RELAY_LOG"

log "Creating session '$SESSION' with 3-pane layout..."

# Layout:
# ┌──────────┬──────────────────┐
# │          │   CC  (50%)      │
# │   OC     ├──────────────────┤
# │  (50%)   │   CX  (50%)     │
# └──────────┴──────────────────┘

# Create session with OC pane (left side)
tmux new-session -d -s "$SESSION" -n main -c "$OC_DIR"
OC_PANE=$(tmux display-message -p -t "$SESSION:main" '#{pane_id}')

# Split right column at 50% width — new pane is CC
CC_PANE=$(tmux split-window -h -l 50% -t "$OC_PANE" -c "$CC_DIR" -P -F '#{pane_id}')

# Split CC vertically: bottom 50% becomes CX
CX_PANE=$(tmux split-window -v -l 50% -t "$CC_PANE" -c "$CX_DIR" -P -F '#{pane_id}')

# Name panes
tmux select-pane -t "$OC_PANE" -T "OC"
tmux select-pane -t "$CC_PANE" -T "CC"
tmux select-pane -t "$CX_PANE" -T "CX"

# Set pane border format to show titles
tmux set-option -t "$SESSION" pane-border-status top
tmux set-option -t "$SESSION" pane-border-format " #{pane_title} "

# Set @role pane options (used by admin-register-panes.sh for identification)
tmux set-option -p -t "$OC_PANE" @role oc
tmux set-option -p -t "$CC_PANE" @role cc
tmux set-option -p -t "$CX_PANE" @role cx

# Propagate relay env vars to all panes in this session
for var in RELAY_MAIN_DIR RELAY_SHARE_DIR RELAY_STATE_DIR RELAY_LOG_DIR RELAY_INBOX_DIR RELAY_TMUX_SESSION BEADS_DIR; do
    tmux set-environment -t "$SESSION" "$var" "${!var}"
done

# Select OC pane as default
tmux select-pane -t "$OC_PANE"

# Allow shells in new panes to fully initialize before sending keys.
# Without this, send-keys can race with shell startup and replay twice.
sleep 0.5

# Write CLAUDE.md into OC/CC worktrees if not already tracked by git
write_claude_md() {
    local dir="$1"
    local claude_md="$dir/CLAUDE.md"
    # Only write if not already tracked by git
    if ! git -C "$dir" ls-files --error-unmatch CLAUDE.md &>/dev/null; then
        cat > "$claude_md" << 'CLAUDE_EOF'
## Git Workflow (MANDATORY)

- **Work in THIS directory only.** Never write files outside your worktree. Never `cd` to another worktree or the main checkout.
- **Always make NEW commits.** Never `git commit --amend`. Amending breaks merge flow — OC merges your branch to main, and amended commits cause history divergence.
- **OC handles merges.** You commit and push on your branch. OC merges to main. Do not merge, rebase, or cherry-pick to/from main yourself.
- **One logical change per commit.** Don't bundle unrelated fixes.

## Infrastructure Rule

Files in `daemon/`, `bin/`, `systemd/` are infrastructure. You CAN edit them here — they merge to main like any other change, and `install.sh` deploys them system-wide.

Do NOT run `install.sh` from this worktree — it deploys from main after merge.

## Runtime Artifacts (not tracked)

`.beads/last_compact_offset_*` and `state/` are runtime artifacts — do not commit them.
CLAUDE_EOF
        log "Wrote CLAUDE.md to $dir"
    fi
}

# OC runs from main — orchestrator-specific CLAUDE.md
if ! git -C "$OC_DIR" ls-files --error-unmatch CLAUDE.md &>/dev/null; then
    cat > "$OC_DIR/CLAUDE.md" << 'OC_CLAUDE_EOF'
## Role: Orchestrator (OC)

You are the orchestrator. You coordinate CC and CX, review code, and merge branches to main.

## Rules

- **Do NOT write code or edit files in this repo.** Delegate coding to CC or CX via relay.
- **Do NOT commit here.** This is the main checkout. Only merge commits from agent worktree branches.
- **Use relay to communicate:** `relay send cc "..."`, `relay send cx "..."`

## Infrastructure Rule

Files in `daemon/`, `bin/`, `systemd/` are infrastructure. If you find a bug, send the fix to CC.

## Runtime Artifacts (not tracked)

`.beads/last_compact_offset_*` and `state/` are runtime artifacts — do not commit them.
OC_CLAUDE_EOF
    log "Wrote OC CLAUDE.md to $OC_DIR"
fi
write_claude_md "$CC_DIR"

# Write project-dirs.json for relay-daemon idle detection (atomic write)
OC_PROJECT_DIR="$HOME/.claude/projects/$(dir_to_slug "$OC_DIR")"
CC_PROJECT_DIR="$HOME/.claude/projects/$(dir_to_slug "$CC_DIR")"
PROJECT_DIRS_JSON="$RELAY_STATE_DIR/project-dirs.json"
TMP_PROJ="$PROJECT_DIRS_JSON.tmp.$$"
printf '{"oc":"%s","cc":"%s","cx":"%s"}\n' "$OC_PROJECT_DIR" "$CC_PROJECT_DIR" "$CX_DIR" > "$TMP_PROJ"
mv "$TMP_PROJ" "$PROJECT_DIRS_JSON"
log "Project dirs written to $PROJECT_DIRS_JSON"

log "Layout created. Pane IDs:"
tmux list-panes -t "$SESSION:main" -F "  #{pane_title}: #{pane_id}"

log ""
log "Launching agents with AGENT_ROLE set..."

# Launch agents — panes.json NOT written yet (written after startup delay below)
# Export all RELAY_* vars directly so the initial shell has them immediately
# (tmux set-environment only affects newly spawned shells, not existing ones)
RELAY_EXPORTS="RELAY_MAIN_DIR=$RELAY_MAIN_DIR RELAY_SHARE_DIR=$RELAY_SHARE_DIR RELAY_STATE_DIR=$RELAY_STATE_DIR RELAY_LOG_DIR=$RELAY_LOG_DIR RELAY_INBOX_DIR=$RELAY_INBOX_DIR RELAY_TMUX_SESSION=$RELAY_TMUX_SESSION BEADS_DIR=$BEADS_DIR"
tmux send-keys -t "$OC_PANE" "export AGENT_ROLE=oc $RELAY_EXPORTS && $OC_CMD" Enter
tmux send-keys -t "$CC_PANE" "export AGENT_ROLE=cc $RELAY_EXPORTS && $CC_CMD" Enter
tmux send-keys -t "$CX_PANE" "export AGENT_ROLE=cx $RELAY_EXPORTS && $CX_CMD" Enter

log ""
log "Agents launched:"
log "  OC:    $OC_CMD (in $OC_DIR)"
log "  CC:    $CC_CMD (in $CC_DIR)"
log "  CX:    $CX_CMD (in $CX_DIR)"
log ""

# Wait for agents to initialize before registering panes.
# Codex takes ~10s to start; writing panes.json too early causes relay to
# route messages to the zsh shell before Codex is running.
log "Waiting 15s for agents to initialize..."
sleep 15

# Write pane map for relay daemon (3 panes, no admin)
PANE_MAP="$RELAY_STATE_DIR/panes.json"
log "Writing pane map to $PANE_MAP"
printf '{"panes":{"oc":"%s","cc":"%s","cx":"%s"},"version":1,"registered_at":"%s"}\n' \
    "$OC_PANE" "$CC_PANE" "$CX_PANE" "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > "$PANE_MAP"

# Force-kill stale processes before starting new ones (two-phase)
RELAY_PID_FILE="$RELAY_STATE_DIR/relay-daemon.pid"
ADMIN_PID_FILE="$RELAY_STATE_DIR/admin-loop.pid"
KILLED_STALE=false

# Phase 1: Kill known PIDs from pidfiles
for pidfile in "$RELAY_PID_FILE" "$ADMIN_PID_FILE"; do
    if [[ -f "$pidfile" ]]; then
        pid=$(cat "$pidfile")
        if kill -0 "$pid" 2>/dev/null; then
            log "Killing stale process (pid=$pid from $pidfile)"
            kill "$pid" 2>/dev/null || true
            KILLED_STALE=true
        fi
        rm -f "$pidfile"
    fi
done

# Phase 2: Sweep for orphaned processes whose environ contains our RELAY_STATE_DIR
# This catches processes from previous launches whose PID files were overwritten
for pid in $(pgrep -f relay-daemon 2>/dev/null || true); do
    if [[ -f "/proc/$pid/environ" ]] && \
       tr '\0' '\n' < "/proc/$pid/environ" 2>/dev/null | grep -qF "RELAY_STATE_DIR=$RELAY_STATE_DIR"; then
        log "Killing orphaned relay-daemon (pid=$pid)"
        kill "$pid" 2>/dev/null || true
        KILLED_STALE=true
    fi
done
for pid in $(pgrep -f admin-loop.sh 2>/dev/null || true); do
    if [[ -f "/proc/$pid/environ" ]] && \
       tr '\0' '\n' < "/proc/$pid/environ" 2>/dev/null | grep -qF "RELAY_STATE_DIR=$RELAY_STATE_DIR"; then
        log "Killing orphaned admin-loop (pid=$pid)"
        kill "$pid" 2>/dev/null || true
        KILLED_STALE=true
    fi
done

# Wait for flock to release after killing stale processes
$KILLED_STALE && sleep 1

# Start relay daemon inline (per-project, not systemd)
# The Go daemon writes its own PID file at $RELAY_STATE_DIR/relay-daemon.pid
setsid relay-daemon >> "$RELAY_LOG_DIR/relay.log" 2>&1 &
sleep 1
if [[ -f "$RELAY_PID_FILE" ]] && kill -0 $(cat "$RELAY_PID_FILE") 2>/dev/null; then
    log "Relay daemon started (pid=$(cat "$RELAY_PID_FILE"))"
else
    err "Relay daemon failed to start — check $RELAY_LOG_DIR/relay.log"
fi

# Start admin loop as background process
if [[ -x "$ADMIN_LOOP" ]]; then
    setsid "$ADMIN_LOOP" >> "$RELAY_LOG_DIR/admin-loop.log" 2>&1 &
    echo $! > "$ADMIN_PID_FILE"
    log "Admin loop started (pid=$!, log=$RELAY_LOG_DIR/admin-loop.log)"
else
    err "Admin loop not found at $ADMIN_LOOP — run install.sh first"
fi

# Auto-start beads daemon if .beads dir exists
if [[ -d "$RELAY_MAIN_DIR/.beads" ]] && command -v bd &>/dev/null; then
    if ! (cd "$RELAY_MAIN_DIR" && bd daemon status --quiet 2>/dev/null); then
        (cd "$RELAY_MAIN_DIR" && bd daemon start 2>/dev/null) || true
        log "Beads daemon started for $RELAY_MAIN_DIR"
    fi
fi

# Attach to session
exec tmux attach -t "$SESSION"
