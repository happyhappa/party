#!/usr/bin/env bash
#
# party-stop - Clean shutdown of a party orchestration session
#
# Captures session briefs from active agents, kills daemons,
# tears down tmux session, and cleans state files.
#
# Usage: party-stop [session-name]
#   If no session name given, auto-detects from $RELAY_TMUX_SESSION or TMUX env.
#
# Safe to run multiple times (idempotent).
#

set -euo pipefail

# Clean stale temp files from previous runs (older than 1 hour)
find /tmp -maxdepth 1 -name 'party-stop-*' -mmin +60 -delete 2>/dev/null || true

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m'

log()  { echo -e "${GREEN}[party-stop]${NC} $1"; }
warn() { echo -e "${YELLOW}[party-stop]${NC} $1"; }
err()  { echo -e "${RED}[party-stop]${NC} $1" >&2; }

# --- Resolve session name ---
SESSION="${1:-${RELAY_TMUX_SESSION:-}}"

if [[ -z "$SESSION" ]]; then
    # Auto-detect from TMUX env (if running inside the tmux session)
    if [[ -n "${TMUX:-}" ]]; then
        SESSION=$(tmux display-message -p '#{session_name}' 2>/dev/null || true)
    fi
fi

if [[ -z "$SESSION" ]]; then
    # Auto-select if exactly one party session is running
    PARTY_SESSIONS=$(tmux list-sessions -F '#{session_name}' 2>/dev/null | grep '^party-' || true)
    PARTY_COUNT=$(echo "$PARTY_SESSIONS" | grep -c . 2>/dev/null || echo 0)
    if [[ "$PARTY_COUNT" -eq 1 && -n "$PARTY_SESSIONS" ]]; then
        SESSION="$PARTY_SESSIONS"
        log "Auto-detected session: $SESSION"
    else
        err "Usage: party-stop [session-name]"
        err "Running party sessions:"
        echo "$PARTY_SESSIONS" | grep . || err '  (none)'
        exit 1
    fi
fi

# --- Self-detach if running inside the target tmux session ---
# If we're inside the session we're about to kill, re-exec detached so
# tmux kill-session doesn't take us down with it.
if [[ "${PARTY_STOP_DETACHED:-}" != "1" && -n "${TMUX:-}" ]]; then
    CURRENT_SESSION=$(tmux display-message -p '#{session_name}' 2>/dev/null || true)
    if [[ "$CURRENT_SESSION" == "$SESSION" ]]; then
        SAFE_SESSION="${SESSION//[^A-Za-z0-9._-]/_}"
        DETACH_LOG="/tmp/party-stop-${SAFE_SESSION}-$(date +%s).log"
        : >>"$DETACH_LOG"  # pre-create so file exists even if setsid fails
        log "Detaching from target session (log: $DETACH_LOG)"
        PARTY_STOP_DETACHED=1 setsid env -u TMUX "$0" "$SESSION" \
            >>"$DETACH_LOG" 2>&1 </dev/null &
        exit 0
    else
        log "Running in-process (inside tmux but different session: current=${CURRENT_SESSION:-unset}, target=$SESSION)"
    fi
else
    TMUX_STATE="${TMUX:+set}"; TMUX_STATE="${TMUX_STATE:-unset}"
    log "Running in-process (TMUX=$TMUX_STATE, PARTY_STOP_DETACHED=${PARTY_STOP_DETACHED:-unset})"
fi

if ! tmux has-session -t "$SESSION" 2>/dev/null; then
    warn "Session '$SESSION' does not exist (already stopped?)"
    # Still try to clean up state below
fi

# --- Resolve state directory ---
# Always query target session first to avoid cross-session contamination
# (caller's RELAY_STATE_DIR may point to a different session's state)
STATE_DIR=""
if tmux has-session -t "$SESSION" 2>/dev/null; then
    STATE_DIR=$(tmux show-environment -t "$SESSION" RELAY_STATE_DIR 2>/dev/null | cut -d= -f2- || true)
fi
# Fallback to caller env only if target query failed (session already dead)
if [[ -z "$STATE_DIR" ]]; then
    if [[ -n "${RELAY_STATE_DIR:-}" ]]; then
        warn "Using caller RELAY_STATE_DIR as fallback (target session env unavailable)"
        STATE_DIR="$RELAY_STATE_DIR"
    fi
fi

if [[ -z "$STATE_DIR" ]]; then
    err "Cannot determine RELAY_STATE_DIR for session '$SESSION'"
    err "Set RELAY_STATE_DIR or pass the session name as argument"
    exit 1
fi

LOG_DIR="${RELAY_LOG_DIR:-$(dirname "$STATE_DIR")/log}"

log "Stopping party session '$SESSION' (state: $STATE_DIR)"

BRIEF_PROMPT_FILE="$HOME/.local/bin/party-brief-prompt.txt"

# --- Step 1: Fork async session brief pipelines ---
# Background brief generation for OC/CC using their JSONL transcripts.
# These run via setsid so they survive tmux teardown. The bd daemon runs
# independently, so beads can be written after the session is killed.
PROJECT_DIRS_FILE="$STATE_DIR/project-dirs.json"
if [[ -f "$PROJECT_DIRS_FILE" ]] && command -v party-jsonl-filter &>/dev/null && \
   command -v claude &>/dev/null && [[ -f "$BRIEF_PROMPT_FILE" ]]; then
    log "Forking async session briefs..."
    declare -A BRIEF_WORKER_PIDS=()
    for ROLE in oc cc; do
        PROJECT_DIR_FOR_ROLE=$(jq -r ".${ROLE} // empty" "$PROJECT_DIRS_FILE" 2>/dev/null || true)
        [[ -z "$PROJECT_DIR_FOR_ROLE" ]] && continue

        LATEST_JSONL=$(ls -t "$PROJECT_DIR_FOR_ROLE"/*.jsonl 2>/dev/null | head -1)
        [[ -z "$LATEST_JSONL" || ! -s "$LATEST_JSONL" ]] && continue

        BRIEF_LOG="/tmp/party-stop-brief-${ROLE}-$(date +%s).log"
        BRIEF_MODEL="${PARTY_BRIEF_MODEL:-sonnet}"
        BRIEF_TIMEOUT="${PARTY_BRIEF_TIMEOUT:-120}"

        # Fork a self-contained worker via setsid (survives tmux kill)
        setsid bash -c '
            set -o pipefail
            ROLE="$1"; JSONL="$2"; PROMPT_FILE="$3"; MODEL="$4"; TIMEOUT="$5"; LOG="$6"
            exec >>"$LOG" 2>&1

            echo "[$(date)] Starting shutdown brief for $ROLE"

            # Filter transcript
            FILTERED=$(mktemp -t "party-stop-filtered-${ROLE}-XXXXXX")
            trap "rm -f $FILTERED" EXIT

            if ! party-jsonl-filter < "$JSONL" > "$FILTERED"; then
                echo "[$(date)] Filter failed for $ROLE"
                exit 1
            fi

            if [[ ! -s "$FILTERED" ]]; then
                echo "[$(date)] Empty filtered output for $ROLE"
                exit 1
            fi

            # Generate brief
            BRIEF_OUTPUT=$(mktemp -t "party-stop-brief-${ROLE}-XXXXXX")
            trap "rm -f $FILTERED $BRIEF_OUTPUT" EXIT

            if ! timeout "$TIMEOUT" claude --model "$MODEL" --print -p "$(cat "$PROMPT_FILE")" < "$FILTERED" > "$BRIEF_OUTPUT"; then
                echo "[$(date)] Claude brief generation failed for $ROLE"
                exit 1
            fi

            if [[ ! -s "$BRIEF_OUTPUT" ]]; then
                echo "[$(date)] Empty brief output for $ROLE"
                exit 1
            fi

            # Write bead
            if command -v bd &>/dev/null; then
                bd create \
                    --type task \
                    --title "${ROLE} shutdown brief $(date "+%Y-%m-%d %H:%M")" \
                    --label "role:${ROLE}" \
                    --label "source:shutdown" \
                    --label "kind:session_brief" \
                    --description "$(cat "$BRIEF_OUTPUT")" --silent >/dev/null 2>&1 || {
                    echo "[$(date)] Bead write failed for $ROLE"
                    exit 1
                }
            fi

            echo "[$(date)] Shutdown brief for $ROLE completed"
        ' _ "$ROLE" "$LATEST_JSONL" "$BRIEF_PROMPT_FILE" "$BRIEF_MODEL" "$BRIEF_TIMEOUT" "$BRIEF_LOG" \
          </dev/null &
        BRIEF_WORKER_PIDS[$ROLE]=$!
        log "  $ROLE: brief pipeline forked (pid=${BRIEF_WORKER_PIDS[$ROLE]}, log: $BRIEF_LOG)"
    done
    # Write worker PIDs for external monitoring
    if [[ ${#BRIEF_WORKER_PIDS[@]} -gt 0 ]]; then
        printf '%s\n' "${BRIEF_WORKER_PIDS[@]}" > "$STATE_DIR/brief-worker-pids"
    fi
else
    if [[ ! -f "$PROJECT_DIRS_FILE" ]]; then
        warn "No project-dirs.json — skipping async briefs"
    else
        warn "Missing party-jsonl-filter, claude, or brief prompt — skipping async briefs"
    fi
fi

# --- Step 1b: Verify async brief workers ---
# Workers forked via setsid may complete quickly (success) or crash.
# Check if still running; if not, inspect log for success sentinel.
if [[ -n "${BRIEF_WORKER_PIDS+x}" && ${#BRIEF_WORKER_PIDS[@]} -gt 0 ]]; then
    for ROLE in "${!BRIEF_WORKER_PIDS[@]}"; do
        WPID="${BRIEF_WORKER_PIDS[$ROLE]}"
        if kill -0 "$WPID" 2>/dev/null; then
            log "Brief worker for $ROLE (pid=$WPID) still running"
        else
            WORKER_LOG="/tmp/party-stop-brief-${ROLE}-"*".log"
            # shellcheck disable=SC2086
            LATEST_WORKER_LOG=$(ls -t $WORKER_LOG 2>/dev/null | head -1)
            if [[ -n "$LATEST_WORKER_LOG" ]] && grep -qF "completed" "$LATEST_WORKER_LOG" 2>/dev/null; then
                log "Brief worker for $ROLE completed successfully"
            else
                warn "Brief worker for $ROLE (pid=$WPID) exited — check log for details"
            fi
        fi
    done
fi

# --- Step 2: Kill relay daemon ---
kill_by_pidfile() {
    local name="$1" pidfile="$2"
    if [[ -f "$pidfile" ]]; then
        local pid
        pid=$(cat "$pidfile" 2>/dev/null || true)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            log "Killing $name (pid=$pid)"
            kill "$pid" 2>/dev/null || true
            # Wait briefly for clean exit
            local i=0
            while (( i < 10 )) && kill -0 "$pid" 2>/dev/null; do
                sleep 0.2
                (( i++ )) || true
            done
            # Force kill if still alive
            if kill -0 "$pid" 2>/dev/null; then
                warn "$name did not exit cleanly, sending SIGKILL"
                kill -9 "$pid" 2>/dev/null || true
            fi
        else
            warn "$name pidfile exists but process not running (stale pid=$pid)"
        fi
        rm -f "$pidfile"
    else
        warn "No pidfile for $name"
    fi
}

kill_by_pidfile "relay-daemon" "$STATE_DIR/relay-daemon.pid"

# --- Step 3: Kill admin-watchdog ---
kill_by_pidfile "admin-watchdog" "$STATE_DIR/admin-watchdog.pid"

# --- Step 4: Sweep for orphaned processes (belt + suspenders) ---
for pattern in relay-daemon admin-watchdog.sh; do
    for pid in $(pgrep -f "$pattern" 2>/dev/null || true); do
        if [[ -f "/proc/$pid/environ" ]] && \
           tr '\0' '\n' < "/proc/$pid/environ" 2>/dev/null | grep -qF "RELAY_STATE_DIR=$STATE_DIR"; then
            warn "Killing orphaned $pattern (pid=$pid)"
            kill "$pid" 2>/dev/null || true
        fi
    done
done

# --- Step 5: Kill tmux session ---
if tmux has-session -t "$SESSION" 2>/dev/null; then
    log "Killing tmux session '$SESSION'"
    tmux kill-session -t "$SESSION" 2>/dev/null || true
else
    warn "tmux session '$SESSION' already gone"
fi

# --- Step 6: Clean state files ---
log "Cleaning state files..."
CLEANED=0
for f in panes.json admin-watchdog.pid relay-daemon.pid admin-watchdog.heartbeat \
         health-hash-oc.txt health-hash-cc.txt health-hash-cx.txt \
         project-dirs.json brief-worker-pids; do
    if [[ -f "$STATE_DIR/$f" ]]; then
        rm -f "$STATE_DIR/$f"
        (( CLEANED++ )) || true
    fi
done
# Clean lock files
for f in "$STATE_DIR"/pre-compact-*.lock; do
    [[ -f "$f" ]] && rm -f "$f" && (( CLEANED++ )) || true
done
log "  Removed $CLEANED state files"

# --- Done ---
log "Session '$SESSION' stopped cleanly."
